# 技术交底书 - 补充部分（3.2.3-3.2.5模块）

> 此文件包含需要插入到《专利技术交底书.md》第1787行之后的内容

---

#### 3.2.3 编剧Agent模块（核心模块）

##### 模块功能概述

编剧Agent模块是本发明的核心模块之一，负责根据业务经验和训练目标，生成采用**分层控制机制**的AI陪练剧本。它模拟专业编剧的能力，能够：
- 设计剧本的整体结构
- 生成三层控制机制（全局/范围/细致）
- 填充具体的对话逻辑和响应策略

##### 详细工作流程

**第一步：接收输入**

编剧Agent接收两个核心输入：
1. **结构化业务经验**（来自业务专家Agent）
   - 包含：核心概念、关键流程、能力要求、典型情况
2. **用户关切点**（训练目标）
   - 例如："训练销售人员的产品介绍能力和客户疑虑应对能力"

**第二步：设计剧本整体结构**

编剧Agent首先进行剧本的整体规划，这是编剧工作的第一步：

**2.1 确定场景设定**

根据业务经验中的行业和场景，设计陪练的具体场景：
- 场景介绍（简要描述，让使用者快速了解）
  - 例如："模拟新能源汽车电机厂商采购负责人首次接触场景"
- 场景详情（详细描述，提供丰富的上下文）
  - 包括：具体环境、人物关系、背景信息
  - 例如："你作为金田铜业营销专员，拜访一家新能源汽车电机厂商的采购负责人张明。对方对铜材供应商的选择非常谨慎，你需要全面展示公司实力..."

**2.2 确定对话目标**

明确这次陪练要训练学员的什么能力：
- 结合用户关切点
- 转化为具体的对话目标
- 例如："训练学员的公司介绍能力、技术优势阐述能力、客户疑虑应对能力"

**2.3 任务分解**

根据业务经验中的"关键流程"，将对话过程分解为多个训练任务：
- 每个任务对应业务流程的一个关键步骤
- 每个任务聚焦一个能力点的训练

例如，对于B2B销售场景：
```
任务1：公司概况介绍（训练公司介绍能力）
任务2：技术优势阐述（训练技术讲解能力）
任务3：质量体系说明（训练质量承诺能力）
任务4：行业应用案例（训练案例应用能力）
任务5：定制化能力展示（训练服务展示能力）
```

任务的分解原则：
- 符合实际业务流程的顺序
- 每个任务目标明确、可评估
- 任务之间有逻辑递进关系
- 任务数量适中（通常3-6个）

**第三步：生成全局控制层**

全局控制层是分层控制机制的第一层，它定义AI"是谁"。

**3.1 设计AI角色人设**

编剧Agent需要设计一个真实可信的角色，包括：

**角色身份**：
- 确定角色的职位、所属公司/组织
- 要符合业务场景
- 例如："张明，新能源汽车电机厂商的采购负责人"

**性别和年龄**：
- 选择合适的性别和年龄
- 影响角色的表达方式和行为模式
- 例如："男，38岁"

**性格特点**：
- 设计符合场景的性格特点
- 性格要有助于训练目标
  - 如果要训练学员应对挑战，设计一个挑剔的角色
  - 如果要训练学员的耐心，设计一个啰嗦的角色
- 例如："技术型采购、数据驱动、注重细节、对供应商要求严格"

这样设计性格的原因：
- "技术型"：会关注技术细节，学员需要技术讲解能力
- "数据驱动"：会要求具体数据，学员需要用数据说服
- "注重细节"：会追问细节，学员需要准备充分
- "要求严格"：会挑剔质疑，学员需要应对能力

**3.2 设计AI背景知识**

这是非常关键的一步，需要**明确角色的知识边界**：

**角色应该知道的**（避免遗漏）：
- 行业基本知识
- 角色职位应该掌握的专业知识
- 例如："你了解行业基本技术参数（如PDIV、耐电晕等概念）"

**角色不应该知道的**（防止幻觉）：
- 明确不在角色知识范围内的内容
- 例如："你对金田铜业的具体情况不熟悉"
- 例如："你不是技术专家，不会深入讲解技术原理"

**角色的立场和观点**：
- 角色对事物的看法和态度
- 例如："你对材料性能要求很高，特别关注耐高压、耐高温特性"

为什么要这么设计：
1. **防止AI胡编乱造**：明确"不知道什么"，AI就不会编造
2. **符合角色逻辑**：采购负责人不会像技术专家一样深入讲解技术
3. **保持真实性**：真实的人都有知识边界，AI也应该有

**3.3 编写全局控制层的Prompt**

将以上设计转化为Prompt，让大语言模型生成：

```
Prompt示例：

"你是一个专业编剧，正在为AI陪练设计角色人设。

【业务场景】
行业：{行业}
场景：{业务场景}

【训练目标】
{用户关切点}

请设计AI扮演的角色人设，包括：

1. 角色身份
   - 职位、所属公司/组织
   - 要真实可信，符合业务场景

2. 性别、年龄
   - 选择合适的性别和年龄
   - 影响角色的表达方式

3. 性格特点
   - 设计符合场景的性格
   - 性格要有助于训练目标
   - 如果要训练应对挑战，可以设计挑剔的角色

4. 背景知识
   - 明确角色"应该知道什么"
   - **重要**：明确角色"不应该知道什么"
   - 说明角色的立场和观点

以JSON格式输出：
{
  'aiRole': '角色描述',
  'aiGender': '性别',
  'aiAge': '年龄',
  'aiPersonalityTraits': '性格特点',
  'aiBackgroundKnowledge': '背景知识（要明确知识边界）'
}

要求：
- 人设真实可信，符合业务场景
- 性格有助于训练目标
- **必须明确知识边界，防止AI胡编乱造**
"
```

**第四步：为每个任务生成范围控制层**

范围控制层是分层控制机制的第二层，它定义AI在每个任务中"怎么想"。

对每个任务（从任务分解中得到），编剧Agent需要生成：

**4.1 设计开场白**

开场白是AI启动该任务时的引导性话语：
- 要自然地引入这个任务
- 要体现角色的人设和性格
- 可以包含强制性表达指令（确保AI一定会说）

强制性表达示例：
```json
{
  "aiOpeningStatement": "在一开始，你一定会一字不差地直接说'我们特别关注材料的耐高压性能，你们在这方面有什么独特技术？'"
}
```

为什么要"一字不差"：
- 对于关键的任务启动语，需要AI精确执行
- 防止AI用其他方式启动，导致任务流程混乱

**4.2 设计思维原则**

思维原则是这个任务的"思考框架"，说明AI在这个任务中：

**应该如何思考和判断**：
- 明确判断标准
- 例如："你会通过具体参数判断供应商的真实水平"

**应该关注什么重点**：
- 该任务的关注焦点
- 例如："你对技术细节非常关注"

**应该采用什么反应模式**：
- 对不同情况的反应方式
- 例如："对空泛的描述你会追问，对有数据支撑的说明你会认可"

思维原则的设计要点：
1. **符合角色人设**：与全局控制层一致
2. **体现任务目标**：围绕该任务要训练的能力
3. **明确具体**：不能笼统，要有具体的判断标准和反应方式

思维原则的Prompt设计：

```
Prompt示例：

"为任务'{任务名称}'设计思维原则。

【任务目标】
{任务训练目标}

【角色人设】
{AI角色的性格和背景}

【业务背景】
{相关业务知识}

请设计该任务的思维原则，说明AI在这个任务中：

1. 应该如何思考和判断
   - 明确判断标准（如：通过什么来判断）
   - 例如：'你会通过数据真实性和量产稳定性判断技术水平'

2. 应该关注什么重点
   - 该任务的关注焦点
   - 例如：'你特别关注技术参数是否有数据支撑'

3. 应该采用什么反应模式
   - 对不同情况如何反应
   - 例如：'对空泛的描述你会追问，对有数据支撑的说明你会认可'

要求：
- 思维原则要符合角色人设
- 要体现该任务的训练目的
- 要明确具体，不能笼统
- 以文字段落形式输出
"
```

**第五步：为每个任务生成细致控制层**

细致控制层是分层控制机制的第三层，它定义AI在特定情况下"怎么说"。

**5.1 设计行为响应表**

行为响应表是"学员行为 → AI响应"的映射表，需要预定义：

**典型正确行为及AI响应**：
- 识别学员的正确行为
- 设计AI如何鼓励和引导

示例：
```json
{
  "studentBehavior": "准确说出公司成立年份和上市情况",
  "aiResponse": "点头表示认可'嗯，看来是家老牌企业'"
}
```

**典型错误行为及AI响应**：
- 识别学员的错误行为
- 设计AI如何纠正和提示

示例：
```json
{
  "studentBehavior": "只提到公司名称，未具体展开介绍",
  "aiResponse": "追问'能具体说说你们公司的规模和发展历程吗？'"
}
```

**边缘情况及AI响应**：
- 识别特殊情况
- 设计AI如何应对

示例：
```json
{
  "studentBehavior": "混淆不同产品的检测标准",
  "aiResponse": "皱眉表示怀疑'你确定扁线和圆线用同一套检测标准？'"
}
```

**5.2 行为响应表的设计原则**

**覆盖性**：
- 要覆盖该任务的主要情况
- 建议每个任务5-10组映射
- 包含：正确行为、错误行为、边缘情况

**可识别性**：
- 学员行为描述要具体、可识别
- AI能够判断学员的行为是否匹配某个预定义行为
- ❌ 错误："学员回答不好" （太模糊）
- ✅ 正确："学员只提到公司名称，未具体展开介绍" （具体可识别）

**可操作性**：
- AI响应要具体、可直接执行
- ❌ 错误："表示不满意" （不够具体）
- ✅ 正确："追问'能具体说说你们公司的规模和发展历程吗？'" （具体可执行）

**与思维原则一致**：
- 行为响应表要符合该任务的思维原则
- 例如：思维原则说"对空泛描述会追问"，行为响应表就要包含对应的映射

**5.3 生成行为响应表的Prompt设计**

```
Prompt示例：

"为任务'{任务名称}'设计行为响应表。

【任务目标】
{任务训练目标}

【思维原则】
{该任务的思维原则}

【业务背景】
{相关业务知识和典型情况}

请预设学员可能的典型行为，并为每种行为设计AI的响应策略。

需要覆盖三类情况：

1. 学员的典型正确行为
   - 学员表现正确时，AI如何鼓励和引导
   - 例如：学员准确说出关键技术参数 → AI表示认可并继续深入

2. 学员的典型错误行为
   - 学员表现错误时，AI如何纠正和提示
   - 例如：学员使用空泛话术缺少数据 → AI追问具体数据

3. 边缘情况或特殊情况
   - 学员表现不清晰或特殊时，AI如何应对
   - 例如：学员混淆概念 → AI提出质疑引导纠正

输出格式：
[
  {
    'studentBehavior': '学员具体行为描述（要具体、可识别）',
    'aiResponse': 'AI对应的响应策略（要具体、可操作）'
  },
  ...
]

要求：
- 每个任务至少5-10组映射
- 行为描述要具体，AI能识别匹配
- 响应策略要具体，AI能直接执行
- 要符合该任务的思维原则
- 覆盖该任务的主要情况
"
```

**第六步：组装完整剧本**

完成所有任务的三层控制生成后，编剧Agent组装完整剧本：

```json
{
  "scriptName": "剧本名称（自动生成，概括场景）",
  "sceneIntroduction": "场景介绍（简要描述）",
  "sceneDetails": "场景详情（详细描述）",
  "dialogueObjective": "对话目标（用户关切点）",

  // 全局控制层
  "aiRole": {
    "aiRole": "AI角色",
    "aiGender": "性别",
    "aiAge": "年龄",
    "aiPersonalityTraits": "性格特点",
    "aiBackgroundKnowledge": "背景知识（含知识边界）"
  },

  // 任务列表（每个任务包含范围控制和细致控制）
  "tasks": [
    {
      "taskName": "任务1名称",
      "aiOpeningStatement": "开场白",
      "aiMindsetPrinciples": "思维原则（范围控制层）",
      "behaviorResponseTable": [
        {
          "studentBehavior": "学员行为",
          "aiResponse": "AI响应"
        },
        ...
      ]
    },
    {
      "taskName": "任务2名称",
      ...
    },
    ...
  ],

  "completionStatement": "通关结束语（所有任务完成后）"
}
```

**第七步：输出JSON格式剧本**

编剧Agent将剧本输出为标准的JSON格式，便于：
1. AI陪练系统直接读取和使用
2. 评估Agent进行质量评估
3. 存储和管理

##### 关键技术实现（代码示例）

```python
def generate_script(business_experience, user_focus):
    """
    生成完整AI陪练剧本

    参数：
        business_experience: 结构化业务经验
        user_focus: 用户关切点

    返回：
        script: 完整剧本（JSON格式）
    """

    print("正在生成AI陪练剧本...")

    # 步骤1：设计剧本整体结构
    print("步骤1：设计剧本整体结构...")

    # 1.1 设计场景
    scene_intro, scene_details = design_scene(business_experience)

    # 1.2 分解任务
    tasks_outline = decompose_tasks(business_experience, user_focus)
    print(f"已分解为{len(tasks_outline)}个任务")

    # 步骤2：生成全局控制层
    print("步骤2：生成全局控制层（AI人设和背景知识）...")
    global_control = generate_global_control(
        business_experience=business_experience,
        user_focus=user_focus
    )
    print(f"角色：{global_control['aiRole']}")

    # 步骤3：为每个任务生成范围控制层和细致控制层
    print("步骤3：为每个任务生成控制机制...")
    complete_tasks = []

    for i, task_outline in enumerate(tasks_outline):
        print(f"正在生成任务{i+1}：{task_outline['名称']}...")

        # 3.1 生成开场白
        opening = generate_opening_statement(
            task=task_outline,
            ai_role=global_control
        )

        # 3.2 生成范围控制层（思维原则）
        mindset = generate_mindset_principles(
            task=task_outline,
            ai_role=global_control,
            business_experience=business_experience
        )

        # 3.3 生成细致控制层（行为响应表）
        behavior_table = generate_behavior_response_table(
            task=task_outline,
            mindset=mindset,
            business_experience=business_experience
        )

        # 组装任务
        complete_task = {
            "taskName": task_outline['名称'],
            "aiOpeningStatement": opening,
            "aiMindsetPrinciples": mindset,
            "behaviorResponseTable": behavior_table
        }
        complete_tasks.append(complete_task)

    # 步骤4：组装完整剧本
    print("步骤4：组装完整剧本...")
    script = {
        "scriptName": generate_script_name(business_experience, user_focus),
        "sceneIntroduction": scene_intro,
        "sceneDetails": scene_details,
        "dialogueObjective": user_focus,
        "aiRole": global_control,
        "tasks": complete_tasks,
        "completionStatement": generate_completion_statement(global_control)
    }

    print("剧本生成完成！")
    return script


def decompose_tasks(business_experience, user_focus):
    """根据业务流程分解任务"""
    prompt = f"""
    请根据业务流程，将对话过程分解为多个训练任务。

    【业务经验】
    关键流程：{business_experience['关键流程']}
    能力要求：{business_experience['能力要求']}

    【训练目标】
    {user_focus}

    请分解为3-6个任务，每个任务：
    - 对应业务流程的一个步骤
    - 聚焦一个能力点的训练
    - 有明确的训练目标

    以JSON格式输出：
    [
      {{
        '名称': '任务名称',
        '目标': '训练什么能力',
        '业务要点': '相关业务要点'
      }},
      ...
    ]
    """

    result = llm.generate(prompt)
    return parse_json(result)


def generate_global_control(business_experience, user_focus):
    """生成全局控制层"""
    prompt = f"""
    你是一个专业编剧，正在为AI陪练设计角色人设。

    【业务场景】
    行业：{business_experience['行业']}
    场景：{business_experience['业务场景']}

    【训练目标】
    {user_focus}

    请设计AI扮演的角色人设，包括：
    1. 角色身份（职位、所属公司）
    2. 性别、年龄
    3. 性格特点（要有助于训练目标）
    4. 背景知识（**必须明确知识边界**）

    以JSON格式输出：
    {{
      'aiRole': '角色描述',
      'aiGender': '性别',
      'aiAge': '年龄',
      'aiPersonalityTraits': '性格特点',
      'aiBackgroundKnowledge': '背景知识（明确知道什么、不知道什么）'
    }}

    要求：
    - 人设真实可信
    - 性格有助于训练
    - **必须明确知识边界，防止AI胡编乱造**
    """

    result = llm.generate(prompt)
    return parse_json(result)


def generate_mindset_principles(task, ai_role, business_experience):
    """生成范围控制层（思维原则）"""
    prompt = f"""
    为任务'{task['名称']}'设计思维原则。

    【任务目标】
    {task['目标']}

    【角色人设】
    {ai_role['aiPersonalityTraits']}

    【业务要点】
    {task['业务要点']}

    请设计该任务的思维原则，说明AI：
    1. 应该如何思考和判断（判断标准）
    2. 应该关注什么重点
    3. 应该采用什么反应模式

    要求：
    - 符合角色人设
    - 体现任务目标
    - 明确具体

    以文字段落形式输出。
    """

    result = llm.generate(prompt)
    return result.strip()


def generate_behavior_response_table(task, mindset, business_experience):
    """生成细致控制层（行为响应表）"""
    prompt = f"""
    为任务'{task['名称']}'设计行为响应表。

    【任务目标】
    {task['目标']}

    【思维原则】
    {mindset}

    【典型情况】
    {business_experience['典型情况']}

    请预设学员行为并设计AI响应：

    1. 典型正确行为（3-4组）
    2. 典型错误行为（2-3组）
    3. 边缘情况（1-2组）

    输出JSON格式：
    [
      {{
        'studentBehavior': '学员具体行为（要具体可识别）',
        'aiResponse': 'AI响应策略（要具体可操作）'
      }},
      ...
    ]

    要求：
    - 至少5-10组映射
    - 行为描述具体
    - 响应策略具体
    - 符合思维原则
    """

    result = llm.generate(prompt)
    return parse_json(result)
```

##### 分层控制机制的协同工作示例

让我们通过一个完整的对话场景，详细说明三层控制如何协同工作：

**场景**：学员正在向采购负责人介绍产品的耐高压性能

```
【学员发言】
"我们的电磁线耐高压性能很好。"

【AI的处理过程】

==========================================
第1层：全局控制层检查
==========================================

我的身份：张明，采购负责人
我的性格：技术型、数据驱动、注重细节
我的知识：了解行业基本参数，但不是技术专家

✓ 决策1：我应该以采购负责人的身份回应
✓ 决策2：我应该表现出技术型和数据驱动的特点
✓ 决策3：我不应该深入讲解技术原理（因为我不是技术专家）

==========================================
第2层：范围控制层检查
==========================================

当前任务：技术优势阐述
思维原则：
- 对技术细节非常关注
- 通过具体参数判断供应商水平
- 反感空泛的营销话术
- 对空泛描述会追问，对有数据支撑的说明会认可

✓ 决策4：学员的"很好"太空泛，属于营销话术
✓ 决策5：我应该追问具体的技术参数和数据
✓ 决策6：我应该表现出对空泛描述的不满

==========================================
第3层：细致控制层检查
==========================================

学员行为识别：
"使用空泛的营销话术，缺少具体数据"

查找行为响应表：
匹配到：
{
  "studentBehavior": "使用空泛的营销话术，缺少具体数据",
  "aiResponse": "表现出不耐烦'这些我都知道，能说点具体的吗？比如数据？'"
}

✓ 决策7：使用预定义的响应策略

==========================================
综合决策
==========================================

基于三层约束，AI生成回复：

"这些我都知道，能说点具体的吗？比如你们的PDIV测试数据是多少？耐电晕能达到什么水平？"

这个回复体现了：
- 采购负责人的身份（全局控制层）
- 数据驱动和注重细节的性格（全局控制层）
- 对技术参数的关注（范围控制层）
- 对空泛描述的不满（范围控制层）
- 追问具体数据（细致控制层预定义）
```

可以看到：
1. **全局控制层**：始终约束AI的身份和基本特征
2. **范围控制层**：在该任务范围内约束AI的思考和反应方式
3. **细致控制层**：针对特定情况精确控制回应内容
4. 三层协同工作，形成最终的回复

##### 技术特点总结

1. **模拟专业编剧能力**：应用编剧方法论设计剧本结构
2. **分层控制机制**：从全局到细节的系统性约束设计（核心创新）
3. **针对AI特性**：专门针对AI的幻觉、偏离、遵从度下降问题设计约束
4. **结构化输出**：标准JSON格式，便于AI系统使用
5. **可控性强**：通过行为响应表实现精确控制

---

#### 3.2.4 评估Agent模块

##### 模块功能概述

评估Agent模块负责评估编剧Agent生成的剧本质量，并提出改进建议。它模拟专业的剧本审核专家和导演的能力，能够：
- 基于优质剧本库进行评估
- 从多个维度评估质量
- 识别具体问题并提出改进建议

##### 详细工作流程

**第一步：接收待评估剧本**

评估Agent接收编剧Agent生成的初始剧本（JSON格式）。

**第二步：多维度质量评估**

评估Agent从4个维度对剧本进行评估：

**维度1：完整性（权重30%）**

检查剧本是否包含所有必要元素，这是最基础的要求。

**检查项目**：

1. **全局控制层完整性**
   - 是否包含AI角色人设（角色、性别、年龄、性格）
   - 是否包含AI背景知识
   - **重要**：背景知识是否明确了知识边界（知道什么、不知道什么）

2. **任务控制层完整性**
   - 每个任务是否包含开场白
   - 每个任务是否包含思维原则（范围控制层）
   - 每个任务是否包含行为响应表（细致控制层）

3. **行为响应表完整性**
   - 行为响应表是否包含多组映射（建议5-10组）
   - 是否覆盖正确行为、错误行为、边缘情况三类
   - 每个映射是否包含学员行为和AI响应两部分

4. **辅助元素完整性**
   - 是否包含场景介绍、场景详情
   - 是否包含对话目标
   - 是否包含通关结束语

**评估方法**：
- 逐项检查是否存在
- 缺失项扣分
- 给出完整性评分（0-10分）

**维度2：合理性（权重30%）**

检查剧本内容是否合理、符合逻辑、真实可信。

**检查项目**：

1. **角色设定合理性**
   - 角色人设是否符合业务场景
   - 性别、年龄是否合理
   - 性格特点是否真实可信
   - 性格是否有助于训练目标

2. **任务分解合理性**
   - 任务分解是否符合业务流程
   - 任务数量是否适中（通常3-6个）
   - 任务之间是否有逻辑递进关系
   - 每个任务的目标是否明确

3. **思维原则合理性**
   - 思维原则是否符合角色人设
   - 是否体现任务目标
   - 判断标准是否明确合理

4. **行为响应合理性**
   - 学员行为描述是否真实常见
   - AI响应是否恰当
   - 响应是否符合角色身份和性格

**评估方法**：
- 检查每个要素的合理性
- 发现不合理之处
- 给出合理性评分（0-10分）

**维度3：约束性（权重25%）**

检查剧本对AI的约束是否有效，这是本发明的核心关注点。

**检查项目**：

1. **知识边界约束**
   - 全局控制层的背景知识是否明确了知识边界
   - 是否清楚说明了"知道什么"和"不知道什么"
   - 能否有效防止AI胡编乱造（幻觉）

2. **思维约束有效性**
   - 思维原则是否足够具体
   - 是否能有效约束AI的思考方向
   - 是否规定了明确的判断标准和反应模式

3. **行为约束精确性**
   - 行为响应表的覆盖是否充分
   - 学员行为描述是否具体可识别
   - AI响应是否具体可操作
   - 能否精确控制AI在特定情况下的回应

4. **三层控制协同性**
   - 三层控制是否逻辑一致
   - 范围控制层是否符合全局控制层
   - 细致控制层是否符合范围控制层
   - 三层是否形成有效的约束体系

**评估方法**：
- 检查每层控制的有效性
- 检查三层的协同性
- 评估整体约束能力
- 给出约束性评分（0-10分）

**维度4：一致性（权重15%）**

检查剧本各部分之间是否一致，有无矛盾。

**检查项目**：

1. **任务与目标一致性**
   - 各任务是否与整体对话目标一致
   - 任务分解是否支撑训练目标

2. **行为响应与思维原则一致性**
   - 行为响应表是否符合思维原则
   - 两者是否相互配合

3. **人设一致性**
   - AI人设是否在所有任务中贯穿始终
   - 开场白、思维原则、行为响应是否都符合人设

4. **场景一致性**
   - 场景设定是否前后一致
   - 是否存在相互矛盾的描述

**评估方法**：
- 检查各部分之间的一致性
- 识别矛盾之处
- 给出一致性评分（0-10分）

**第三步：计算综合评分**

根据权重计算综合评分：

```
综合评分 = 完整性评分 × 30%
         + 合理性评分 × 30%
         + 约束性评分 × 25%
         + 一致性评分 × 15%
```

判断是否达标：
- 综合评分 ≥ 8.0分：达标，可以输出
- 综合评分 < 8.0分：不达标，需要优化

**第四步：与优质剧本库对比**

除了基于标准评估，评估Agent还会将生成的剧本与优质剧本库中的案例对比：

**对比流程**：

1. **查找同类剧本**
   - 在优质剧本库中查找相同行业、相同场景的优质剧本
   - 例如：新能源行业 + B2B销售场景

2. **对比分析**
   - 对比剧本结构设计
   - 对比全局控制层的设计
   - 对比思维原则的设计
   - 对比行为响应表的设计

3. **识别差距**
   - 找出生成剧本与优质剧本的差距
   - 识别可以借鉴的优秀实践

4. **提供参考**
   - 在改进建议中引用优质剧本的优秀实践
   - 为优化提供具体参考

**第五步：生成改进建议**

对于发现的每个问题，评估Agent生成详细的改进建议：

**改进建议包含**：

1. **问题的具体位置**
   - 精确定位到剧本的哪个部分
   - 例如："tasks[1].aiMindsetPrinciples"（第2个任务的思维原则）

2. **问题是什么**
   - 清楚说明具体问题
   - 例如："任务2的思维原则过于笼统"

3. **为什么这是问题**
   - 解释问题的影响
   - 例如："缺少具体的判断标准，AI难以准确把握回应逻辑"

4. **具体的改进方案**
   - 提供可操作的改进方法
   - 例如："增加具体的判断标准，如'你会通过数据真实性（是否提供检测报告）和量产稳定性（是否说明批量情况）来判断技术水平'"

5. **参考优质剧本的优秀实践**
   - 引用优质剧本中的类似做法
   - 例如："优质剧本XYZ中，思维原则明确规定了3个判断维度和对应的反应方式"

**第六步：输出评估报告**

评估Agent输出完整的评估报告（JSON格式）：

```json
{
  "overall_score": 7.5,
  "pass": false,
  "dimension_scores": {
    "完整性": 8.0,
    "合理性": 8.5,
    "约束性": 6.5,
    "一致性": 7.0
  },
  "issues": {
    "完整性问题": [],
    "合理性问题": [
      {
        "位置": "tasks[3]",
        "问题": "任务4的开场白过于直接",
        "详情": "直接问客户名称可能显得唐突"
      }
    ],
    "约束性问题": [
      {
        "位置": "tasks[1].aiMindsetPrinciples",
        "问题": "任务2的思维原则过于笼统",
        "详情": "只说'你需要判断技术水平'，但没有说明如何判断"
      },
      {
        "位置": "tasks[2].behaviorResponseTable",
        "问题": "任务3的行为响应表覆盖不足",
        "详情": "只有3组映射，缺少对错误行为的响应"
      }
    ],
    "一致性问题": []
  },
  "improvement_suggestions": [
    {
      "位置": "tasks[1].aiMindsetPrinciples",
      "问题": "任务2的思维原则过于笼统",
      "原因": "缺少具体的判断标准和关注重点，AI难以准确把握回应逻辑",
      "改进方案": "增加具体的判断标准，如'你会通过数据真实性（是否提供检测报告）、量产稳定性（是否说明批量情况）来判断技术水平。对于空泛的描述你会追问，对于有数据支撑的说明你会认可。'",
      "参考案例": "优质剧本XYZ中，思维原则明确规定了3个判断维度（数据真实性、量产稳定性、应用广泛性）和对应的反应方式（追问 vs 认可）"
    },
    {
      "位置": "tasks[2].behaviorResponseTable",
      "问题": "任务3的行为响应表覆盖不足",
      "原因": "只有3组映射，缺少对学员错误行为的响应，无法有效训练学员",
      "改进方案": "增加对学员典型错误行为的响应，如：\n- 学员混淆检测标准 → AI提出质疑\n- 学员夸大不良率控制水平 → AI追问证据\n- 学员回避追溯体系 → AI表示担忧",
      "参考案例": "优质剧本ABC中，每个任务的行为响应表都包含至少2-3组对错误行为的响应"
    }
  ],
  "reference_comparison": {
    "同类优质剧本": "新能源B2B销售剧本XYZ",
    "评分": 9.2,
    "优秀特征": [
      "思维原则非常具体，规定了明确的判断维度",
      "行为响应表覆盖全面，包含8-10组映射",
      "三层控制机制配合紧密，约束性强"
    ]
  }
}
```

##### 关键技术实现（代码示例）

```python
def evaluate_script(generated_script, quality_script_database):
    """
    评估生成的剧本

    参数：
        generated_script: 待评估剧本
        quality_script_database: 优质剧本库

    返回：
        evaluation_report: 评估报告（JSON）
    """

    print("正在评估剧本质量...")

    # 步骤1：完整性评估
    print("维度1：评估完整性...")
    completeness_score, completeness_issues = evaluate_completeness(
        generated_script
    )
    print(f"完整性评分：{completeness_score}")

    # 步骤2：合理性评估
    print("维度2：评估合理性...")
    rationality_score, rationality_issues = evaluate_rationality(
        generated_script
    )
    print(f"合理性评分：{rationality_score}")

    # 步骤3：约束性评估
    print("维度3：评估约束性...")
    constraint_score, constraint_issues = evaluate_constraint(
        generated_script
    )
    print(f"约束性评分：{constraint_score}")

    # 步骤4：一致性评估
    print("维度4：评估一致性...")
    consistency_score, consistency_issues = evaluate_consistency(
        generated_script
    )
    print(f"一致性评分：{consistency_score}")

    # 步骤5：计算综合评分
    overall_score = (
        completeness_score * 0.30 +
        rationality_score * 0.30 +
        constraint_score * 0.25 +
        consistency_score * 0.15
    )
    print(f"综合评分：{overall_score}")

    # 步骤6：与优质剧本对比
    print("正在与优质剧本库对比...")
    reference_comparison = compare_with_quality_scripts(
        generated_script,
        quality_script_database
    )

    # 步骤7：生成改进建议
    print("正在生成改进建议...")
    all_issues = {
        "完整性问题": completeness_issues,
        "合理性问题": rationality_issues,
        "约束性问题": constraint_issues,
        "一致性问题": consistency_issues
    }

    improvement_suggestions = generate_improvement_suggestions(
        all_issues,
        reference_comparison
    )

    # 步骤8：生成评估报告
    evaluation_report = {
        "overall_score": round(overall_score, 1),
        "pass": overall_score >= 8.0,
        "dimension_scores": {
            "完整性": completeness_score,
            "合理性": rationality_score,
            "约束性": constraint_score,
            "一致性": consistency_score
        },
        "issues": all_issues,
        "improvement_suggestions": improvement_suggestions,
        "reference_comparison": reference_comparison
    }

    if evaluation_report["pass"]:
        print("✓ 剧本评估通过！")
    else:
        print(f"✗ 剧本评估未通过，需要优化（{len(improvement_suggestions)}个问题）")

    return evaluation_report


def evaluate_completeness(script):
    """评估完整性"""
    issues = []
    score = 10.0

    # 检查全局控制层
    if 'aiRole' not in script:
        issues.append({"位置": "aiRole", "问题": "缺少AI角色定义"})
        score -= 2.0
    else:
        required_fields = ['aiRole', 'aiGender', 'aiAge', 'aiPersonalityTraits', 'aiBackgroundKnowledge']
        for field in required_fields:
            if field not in script['aiRole'] or not script['aiRole'][field]:
                issues.append({"位置": f"aiRole.{field}", "问题": f"缺少{field}"})
                score -= 0.5

        # 重点检查背景知识是否明确了知识边界
        bg_knowledge = script['aiRole'].get('aiBackgroundKnowledge', '')
        if '不' not in bg_knowledge and '不知道' not in bg_knowledge:
            issues.append({
                "位置": "aiRole.aiBackgroundKnowledge",
                "问题": "背景知识未明确知识边界",
                "详情": "应该明确角色'不知道什么'，防止AI胡编乱造"
            })
            score -= 1.0

    # 检查任务完整性
    if 'tasks' not in script or not script['tasks']:
        issues.append({"位置": "tasks", "问题": "缺少任务列表"})
        score -= 3.0
    else:
        for i, task in enumerate(script['tasks']):
            # 检查思维原则
            if 'aiMindsetPrinciples' not in task or not task['aiMindsetPrinciples']:
                issues.append({
                    "位置": f"tasks[{i}].aiMindsetPrinciples",
                    "问题": f"任务{i+1}缺少思维原则"
                })
                score -= 0.5

            # 检查行为响应表
            if 'behaviorResponseTable' not in task or not task['behaviorResponseTable']:
                issues.append({
                    "位置": f"tasks[{i}].behaviorResponseTable",
                    "问题": f"任务{i+1}缺少行为响应表"
                })
                score -= 0.5
            elif len(task['behaviorResponseTable']) < 5:
                issues.append({
                    "位置": f"tasks[{i}].behaviorResponseTable",
                    "问题": f"任务{i+1}的行为响应表过少",
                    "详情": f"只有{len(task['behaviorResponseTable'])}组，建议至少5组"
                })
                score -= 0.3

    return max(score, 0.0), issues


def evaluate_constraint(script):
    """评估约束性（核心维度）"""
    issues = []
    score = 10.0

    # 使用大语言模型进行深度评估
    prompt = f"""
    请评估以下AI陪练剧本的约束性，重点关注：

    1. 知识边界约束
       - 背景知识是否明确了知识边界
       - 能否防止AI胡编乱造

    2. 思维约束有效性
       - 思维原则是否具体
       - 是否有明确的判断标准

    3. 行为约束精确性
       - 行为响应表是否覆盖充分
       - 学员行为是否具体可识别
       - AI响应是否具体可操作

    4. 三层控制协同性
       - 三层控制是否逻辑一致

    【剧本】
    {json.dumps(script, ensure_ascii=False, indent=2)}

    请给出：
    1. 约束性评分（0-10）
    2. 发现的问题列表

    以JSON格式输出。
    """

    result = llm.generate(prompt)
    eval_result = parse_json(result)

    score = eval_result['评分']
    issues = eval_result['问题列表']

    return score, issues


def generate_improvement_suggestions(all_issues, reference_comparison):
    """生成改进建议"""
    suggestions = []

    # 对每个问题生成详细的改进建议
    for dimension, issues in all_issues.items():
        if not issues:
            continue

        for issue in issues:
            # 使用大语言模型生成详细建议
            prompt = f"""
            针对以下问题，请提供详细的改进建议：

            【问题信息】
            位置：{issue['位置']}
            问题：{issue['问题']}
            详情：{issue.get('详情', '')}

            【优质剧本参考】
            {json.dumps(reference_comparison, ensure_ascii=False, indent=2)}

            请提供：
            1. 为什么这是问题
            2. 具体的改进方案
            3. 参考优质剧本的优秀实践

            以JSON格式输出：
            {{
              '位置': '...',
              '问题': '...',
              '原因': '...',
              '改进方案': '...',
              '参考案例': '...'
            }}
            """

            result = llm.generate(prompt)
            suggestion = parse_json(result)
            suggestions.append(suggestion)

    return suggestions
```

##### 技术特点总结

1. **多维度评估**：完整性、合理性、约束性、一致性四个维度全面评估
2. **基于优质剧本库**：有专业标准和参考案例
3. **详细改进建议**：不仅指出问题，还提供具体改进方案
4. **自动化**：全自动评估，无需人工参与
5. **客观标准化**：基于统一标准，消除主观性

---

#### 3.2.5 优化模块

##### 模块功能概述

优化模块负责根据评估Agent的改进建议和用户反馈，对剧本进行针对性优化。它的特点是：
- 针对性优化（不是整体重新生成）
- 结合用户反馈
- 支持迭代改进

##### 详细工作流程

**第一步：接收输入**

优化模块接收：
1. **当前剧本**（需要优化的版本）
2. **评估报告**（包含改进建议列表）
3. **用户反馈**（可选，用户试用后的反馈）

**第二步：解析改进建议**

优化模块解析评估报告中的改进建议列表，每个建议包含：
- 问题的具体位置（如：`tasks[1].aiMindsetPrinciples`）
- 问题描述
- 改进方案

**第三步：针对性优化**

对于每个具体问题，优化模块进行针对性优化，而不是整体重新生成：

**3.1 定位问题位置**

根据问题位置信息，精确定位到剧本的哪个部分需要优化：
- 例如：`tasks[1].aiMindsetPrinciples` 表示第2个任务的思维原则

**3.2 获取当前内容**

提取该位置的当前内容：
```python
current_content = script['tasks'][1]['aiMindsetPrinciples']
```

**3.3 调用编剧Agent针对性优化**

将以下信息提供给编剧Agent：
- 当前内容（需要优化的部分）
- 问题描述（为什么需要优化）
- 改进方案（如何优化）
- 上下文信息（剧本的其他部分，确保一致性）

编剧Agent针对这个具体部分进行优化，生成改进后的内容。

**3.4 更新剧本**

用优化后的内容更新剧本的对应位置：
```python
script['tasks'][1]['aiMindsetPrinciples'] = optimized_content
```

**3.5 循环处理所有问题**

重复步骤3.1-3.4，处理评估报告中的所有问题。

**第四步：整合用户反馈（如果有）**

如果用户在试用剧本后提供了反馈，优化模块会进一步调整：

**用户反馈的类型**：
- **行为响应不符合预期**
  - 例如："AI在学员说XXX时，应该YYY，而不是ZZZ"
  - 优化模块识别对应的行为响应，进行调整

- **思维原则需要调整**
  - 例如："AI应该更严格/更宽容"
  - 优化模块调整对应任务的思维原则

- **角色人设需要调整**
  - 例如："AI的性格应该更温和/更强硬"
  - 优化模块调整全局控制层的人设

**整合反馈的流程**：

1. **理解反馈内容**
   - 使用大语言模型理解用户的反馈
   - 识别反馈涉及的位置和需要调整的内容

2. **定位需要调整的位置**
   - 根据反馈确定需要修改剧本的哪个部分

3. **调用编剧Agent调整**
   - 提供用户的期望
   - 生成符合用户期望的内容

4. **更新剧本**
   - 用调整后的内容更新剧本

**第五步：返回优化后的剧本**

完成所有优化后，返回优化后的剧本。

**第六步：迭代优化**

优化后的剧本返回评估Agent重新评估：
- 如果评估通过（≥8.0分）：输出成品剧本
- 如果评估未通过：继续优化（通常最多迭代3-5轮）

迭代优化的好处：
- 持续改进，逐步提升质量
- 每次针对具体问题优化，效率高
- 避免过度优化（设定最大迭代次数）

##### 关键技术实现（代码示例）

```python
def optimize_script(script, evaluation_report, user_feedback=None, iteration=1, max_iterations=5):
    """
    优化剧本

    参数：
        script: 当前剧本
        evaluation_report: 评估报告
        user_feedback: 用户反馈（可选）
        iteration: 当前迭代次数
        max_iterations: 最大迭代次数

    返回：
        optimized_script: 优化后的剧本
    """

    print(f"正在进行第{iteration}轮优化...")

    # 复制剧本，避免修改原始数据
    optimized_script = copy.deepcopy(script)

    # 步骤1：根据评估建议优化
    suggestions = evaluation_report['improvement_suggestions']
    print(f"需要优化{len(suggestions)}个问题")

    for i, suggestion in enumerate(suggestions):
        print(f"正在优化问题{i+1}/{len(suggestions)}：{suggestion['问题']}")

        # 定位问题位置
        location = suggestion['位置']

        # 获取当前内容
        current_content = get_content_by_location(optimized_script, location)

        # 调用编剧Agent针对性优化
        optimized_content = targeted_optimize(
            script=optimized_script,
            location=location,
            current_content=current_content,
            problem=suggestion['问题'],
            improvement=suggestion['改进方案']
        )

        # 更新剧本
        optimized_script = update_script_part(
            optimized_script,
            location,
            optimized_content
        )

        print(f"问题{i+1}已优化")

    # 步骤2：如果有用户反馈，进一步优化
    if user_feedback:
        print("正在整合用户反馈...")
        optimized_script = apply_user_feedback(
            optimized_script,
            user_feedback
        )
        print("用户反馈已整合")

    # 步骤3：重新评估
    print("正在重新评估优化后的剧本...")
    new_evaluation = evaluate_script(optimized_script, quality_script_database)

    if new_evaluation['pass']:
        print(f"✓ 第{iteration}轮优化后，剧本评估通过！")
        return optimized_script
    elif iteration >= max_iterations:
        print(f"⚠ 已达到最大迭代次数({max_iterations})，返回当前版本")
        return optimized_script
    else:
        print(f"✗ 第{iteration}轮优化后，评分{new_evaluation['overall_score']}，继续优化")
        # 递归调用，继续优化
        return optimize_script(
            optimized_script,
            new_evaluation,
            user_feedback=None,  # 用户反馈只用一次
            iteration=iteration + 1,
            max_iterations=max_iterations
        )


def get_content_by_location(script, location):
    """根据位置字符串获取内容"""
    # 解析位置字符串，如 "tasks[1].aiMindsetPrinciples"
    parts = location.replace('[', '.').replace(']', '').split('.')

    content = script
    for part in parts:
        if part.isdigit():
            content = content[int(part)]
        else:
            content = content[part]

    return content


def targeted_optimize(script, location, current_content, problem, improvement):
    """针对特定位置进行优化"""

    # 获取上下文信息（确保优化后与其他部分一致）
    context = extract_context(script, location)

    prompt = f"""
    请优化以下内容。

    【位置】
    {location}

    【当前内容】
    {current_content}

    【问题】
    {problem}

    【改进要求】
    {improvement}

    【上下文信息】
    {json.dumps(context, ensure_ascii=False, indent=2)}

    请提供优化后的内容，要求：
    1. 满足改进要求
    2. 与上下文保持一致
    3. 保持JSON格式（如果原内容是JSON）

    仅输出优化后的内容，不要额外说明。
    """

    optimized = llm.generate(prompt)

    # 如果是JSON格式，解析后返回
    if isinstance(current_content, (dict, list)):
        return parse_json(optimized)
    else:
        return optimized.strip()


def update_script_part(script, location, new_content):
    """更新剧本的特定部分"""
    parts = location.replace('[', '.').replace(']', '').split('.')

    # 构建更新路径
    obj = script
    for i, part in enumerate(parts[:-1]):
        if part.isdigit():
            obj = obj[int(part)]
        else:
            obj = obj[part]

    # 更新最后一级
    last_part = parts[-1]
    if last_part.isdigit():
        obj[int(last_part)] = new_content
    else:
        obj[last_part] = new_content

    return script


def apply_user_feedback(script, user_feedback):
    """整合用户反馈"""

    # 使用大语言模型理解用户反馈
    prompt = f"""
    请分析以下用户反馈，确定需要调整剧本的哪个部分。

    【用户反馈】
    {user_feedback}

    【当前剧本】
    {json.dumps(script, ensure_ascii=False, indent=2)}

    请分析：
    1. 用户反馈涉及剧本的哪个部分（位置）
    2. 用户的具体期望是什么
    3. 如何调整才能满足用户期望

    以JSON格式输出：
    {{
      '位置': '...',
      '用户期望': '...',
      '调整方案': '...'
    }}
    """

    analysis = llm.generate(prompt)
    feedback_analysis = parse_json(analysis)

    # 根据分析结果调整剧本
    location = feedback_analysis['位置']
    current_content = get_content_by_location(script, location)

    optimized_content = targeted_optimize(
        script=script,
        location=location,
        current_content=current_content,
        problem=f"用户反馈：{user_feedback}",
        improvement=feedback_analysis['调整方案']
    )

    script = update_script_part(script, location, optimized_content)

    return script


def extract_context(script, location):
    """提取上下文信息"""
    # 根据位置提取相关上下文
    # 例如，如果优化的是某个任务的思维原则，
    # 上下文应包括：角色人设、该任务的其他信息等

    context = {
        "角色人设": script.get('aiRole', {}),
        "场景设定": {
            "sceneIntroduction": script.get('sceneIntroduction', ''),
            "dialogueObjective": script.get('dialogueObjective', '')
        }
    }

    # 如果优化的是任务相关内容，提取该任务的其他信息
    if 'tasks[' in location:
        task_index = int(location.split('[')[1].split(']')[0])
        context["当前任务"] = script['tasks'][task_index]

    return context
```

##### 优化流程示意图

```
【第1轮优化】
评估报告：发现3个问题
├─ 问题1：思维原则笼统
│  └─ 针对性优化 → 增加具体判断标准
├─ 问题2：行为响应表不足
│  └─ 针对性优化 → 增加5组映射
└─ 问题3：开场白过于直接
   └─ 针对性优化 → 调整表达方式

重新评估 → 评分7.8，不通过

【第2轮优化】
评估报告：发现1个问题
└─ 问题1：某个响应不符合人设
   └─ 针对性优化 → 调整响应策略

重新评估 → 评分8.2，通过 ✓
输出成品剧本
```

##### 技术特点总结

1. **针对性优化**：只优化有问题的部分，不重新生成整体，效率高
2. **保持一致性**：优化时考虑上下文，确保与其他部分一致
3. **结合用户反馈**：自动评估+人工反馈双重保障
4. **迭代机制**：支持多轮优化，持续改进
5. **设定上限**：最多迭代3-5轮，避免过度优化

---

### 3.3 关键技术特征总结

本发明的关键技术特征（与现有技术的明确区分）：

#### 技术特征1：专业Agent组合模拟人类专家能力

**技术内容**：
- 设计了4个专业Agent（知识提取、业务专家、编剧、评估）
- 每个Agent模拟一类人类专家的能力
- Agent之间有明确的职责分工和数据流转

**与现有技术的区别**：
- 现有技术：通用的多Agent框架（如AutoGen、CrewAI）提供基础设施
- 本发明：针对剧本生成的专业Agent设计和协同方案（应用层创新）

**技术价值**：
- 将稀缺的复合型专家能力（业务+编剧+Prompt工程）转化为可复制的Agent
- 自动化完成原本需要多人协作的复杂任务

#### 技术特征2：三层分层控制机制（核心特征）

**技术内容**：
- **全局控制层**：定义AI"是谁"，持续有效
- **范围控制层**：定义AI"怎么想"，任务内有效
- **细致控制层**：定义AI"怎么说"，特定情况触发

**与现有技术的区别**：
- 现有技术：单层Prompt指令，平面化约束
- 本发明：三层控制，漏斗式约束，从宏观到微观系统性设计

**技术价值**：
- 有效防止AI幻觉（明确知识边界）
- 有效防止角色偏离（多层锚定）
- 有效提升可控性（精确控制特定情况）

#### 技术特征3：行为响应表精确控制机制

**技术内容**：
- 预定义"学员行为 → AI响应"的映射表
- 学员行为描述具体可识别
- AI响应策略具体可操作
- 覆盖正确、错误、边缘三类情况

**与现有技术的区别**：
- 现有技术：笼统的指导原则
- 本发明：精确的行为-响应映射

**技术价值**：
- 精确控制AI在已知情况下的回应
- 减少AI"自由发挥"的空间
- 确保训练效果

#### 技术特征4：基于优质剧本库的自动评估与迭代

**技术内容**：
- 构建优质剧本库作为评估基准
- 多维度自动评估（完整性、合理性、约束性、一致性）
- 生成详细改进建议
- 针对性优化+迭代机制

**与现有技术的区别**：
- 现有技术：无自动质量评估，依赖人工
- 本发明：自动评估+优化，无需人工介入

**技术价值**：
- 确保剧本质量稳定
- 持续改进优化
- 降低人工成本

---

### 3.4 替代方案说明

#### 替代方案1：单Agent实现

**方案描述**：
使用单个大语言模型Agent完成所有工作，而不是多个专业Agent协同。

**实现方式**：
```python
def single_agent_generate(business_doc, user_focus):
    """单Agent一次性生成剧本"""
    prompt = f"""
    请基于以下业务文档和训练目标，生成AI陪练剧本。

    业务文档：{business_doc}
    训练目标：{user_focus}

    请输出完整的JSON格式剧本，包括：
    - 场景设定
    - AI角色人设
    - 任务列表（每个任务包含思维原则和行为响应表）
    - ...

    【详细要求】...
    """

    script = llm.generate(prompt)
    return parse_json(script)
```

**优缺点对比**：

| 维度 | 单Agent方案 | 本发明的多Agent方案 |
|------|------------|-------------------|
| 实现复杂度 | 低（一次调用） | 高（多步骤协同） |
| 质量稳定性 | 不稳定 | 稳定（每步专业处理） |
| 质量保证 | 无 | 有（评估+优化） |
| 专业能力 | 泛化 | 专业化分工 |
| 迭代优化 | 不支持 | 支持 |

**适用场景**：
- 简单场景，对质量要求不高
- 快速原型验证
- 资源受限情况下的降级方案

**与本发明的关系**：
本发明的多Agent协同方案是更优的实现方式，但单Agent方案可作为降级方案。

---

#### 替代方案2：两层控制机制

**方案描述**：
简化为两层控制：全局控制层 + 细致控制层，省略范围控制层（思维原则）。

**剧本结构**：
```json
{
  "aiRole": {...},  // 全局控制层
  "tasks": [
    {
      "taskName": "任务名称",
      // 没有思维原则（范围控制层）
      "behaviorResponseTable": [...]  // 直接是细致控制层
    }
  ]
}
```

**优缺点对比**：

| 维度 | 两层方案 | 本发明的三层方案 |
|------|---------|----------------|
| 结构复杂度 | 低 | 中 |
| 任务级约束 | 无 | 有（思维原则） |
| 未预定义情况的处理 | 弱 | 强（思维原则兜底） |
| 控制粒度 | 粗 | 细 |

**适用场景**：
- 非常简单的场景
- 行为可以完全预定义的情况
- 对AI可控性要求不那么高的情况

**与本发明的关系**：
三层控制是更完整、更有效的方案，但在某些简单场景下可简化为两层。

---

#### 替代方案3：人工辅助半自动生成

**方案描述**：
系统自动生成初稿，人工专家审核和修改，再输出最终剧本。

**实现流程**：
```
业务文档 → 自动生成初稿 → 人工专家审核 → 人工修改 → 最终剧本
```

**优缺点对比**：

| 维度 | 人工辅助方案 | 本发明的全自动方案 |
|------|------------|------------------|
| 自动化程度 | 半自动 | 全自动 |
| 质量保证 | 人工把关，更可靠 | 自动评估 |
| 效率 | 中等（仍需人工） | 高（无需人工） |
| 成本 | 中等（需专家时间） | 低（无需专家） |
| 专家依赖 | 仍依赖专家可用性 | 不依赖 |

**适用场景**：
- 初期阶段，质量要求极高
- 特殊或复杂场景
- 过渡阶段

**与本发明的关系**：
本发明的目标是全自动化，但在初期可采用人工辅助方案作为过渡。随着优质剧本库的积累和评估能力的提升，可以逐步过渡到全自动。

---

**（技术交底书第三部分完成）**
